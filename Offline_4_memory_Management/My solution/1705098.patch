diff --git a/.cvsignore b/.cvsignore
old mode 100644
new mode 100755
diff --git a/.dir-locals.el b/.dir-locals.el
old mode 100644
new mode 100755
diff --git a/.gdbinit.tmpl b/.gdbinit.tmpl
old mode 100644
new mode 100755
diff --git a/.gitignore b/.gitignore
old mode 100644
new mode 100755
diff --git a/BUGS b/BUGS
old mode 100644
new mode 100755
diff --git a/LICENSE b/LICENSE
old mode 100644
new mode 100755
diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index 09d790c..3ae92e6
--- a/Makefile
+++ b/Makefile
@@ -181,6 +181,7 @@ UPROGS=\
 	_usertests\
 	_wc\
 	_zombie\
+	_test1\
 
 fs.img: mkfs README $(UPROGS)
 	./mkfs fs.img README $(UPROGS)
@@ -249,7 +250,7 @@ qemu-nox-gdb: fs.img xv6.img .gdbinit
 
 EXTRA=\
 	mkfs.c ulib.c user.h cat.c echo.c forktest.c grep.c kill.c\
-	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c\
+	ln.c ls.c mkdir.c rm.c stressfs.c usertests.c wc.c zombie.c test1.c\
 	printf.c umalloc.c\
 	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
 	.gdbinit.tmpl gdbutil\
diff --git a/Notes b/Notes
old mode 100644
new mode 100755
diff --git a/README b/README
old mode 100644
new mode 100755
diff --git a/TRICKS b/TRICKS
old mode 100644
new mode 100755
diff --git a/asm.h b/asm.h
old mode 100644
new mode 100755
diff --git a/bio.c b/bio.c
old mode 100644
new mode 100755
diff --git a/bootasm.S b/bootasm.S
old mode 100644
new mode 100755
diff --git a/bootmain.c b/bootmain.c
old mode 100644
new mode 100755
diff --git a/buf.h b/buf.h
old mode 100644
new mode 100755
diff --git a/cat.c b/cat.c
old mode 100644
new mode 100755
diff --git a/console.c b/console.c
old mode 100644
new mode 100755
diff --git a/date.h b/date.h
old mode 100644
new mode 100755
diff --git a/defs.h b/defs.h
old mode 100644
new mode 100755
index 82fb982..2d683a9
--- a/defs.h
+++ b/defs.h
@@ -52,6 +52,11 @@ struct inode*   nameiparent(char*, char*);
 int             readi(struct inode*, char*, uint, uint);
 void            stati(struct inode*, struct stat*);
 int             writei(struct inode*, char*, uint, uint);
+int             createSwapFile(struct proc* p);
+int             readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size);
+int             writeToSwapFile(struct proc* p, char* buffer, uint placeOnFile, uint size);
+int             removeSwapFile(struct proc* p);
+
 
 // ide.c
 void            ideinit(void);
@@ -120,10 +125,18 @@ void            userinit(void);
 int             wait(void);
 void            wakeup(void*);
 void            yield(void);
+int             not_init_or_sh(struct proc *);
+void            initNewFeatures(struct proc *);
+void            reset_R(void);
 
 // swtch.S
 void            swtch(struct context**, struct context*);
 
+// sysfile
+struct inode*   create(char *path, short type, short major, short minor);
+int             isdirempty(struct inode *dp);
+
+
 // spinlock.c
 void            acquire(struct spinlock*);
 void            getcallerpcs(void*, uint*);
@@ -185,6 +198,8 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 void            clearpteu(pde_t *pgdir, char *uva);
+void            swapPage_Fifo(uint addr);
+void            reset_RR(void);
 
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
diff --git a/echo.c b/echo.c
old mode 100644
new mode 100755
diff --git a/elf.h b/elf.h
old mode 100644
new mode 100755
diff --git a/entry.S b/entry.S
old mode 100644
new mode 100755
diff --git a/entryother.S b/entryother.S
old mode 100644
new mode 100755
diff --git a/exec.c b/exec.c
old mode 100644
new mode 100755
index b40134f..94f303a
--- a/exec.c
+++ b/exec.c
@@ -18,7 +18,9 @@ exec(char *path, char **argv)
   struct proghdr ph;
   pde_t *pgdir, *oldpgdir;
   struct proc *curproc = myproc();
-
+  //-------------
+  cprintf("Inside exec\n");
+  //-------------------
   begin_op();
 
   if((ip = namei(path)) == 0){
@@ -49,8 +51,16 @@ exec(char *path, char **argv)
       goto bad;
     if(ph.vaddr + ph.memsz < ph.vaddr)
       goto bad;
-    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
-      goto bad;
+    
+    if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0){
+         //-----------------------------added by afnan-------------------------
+         
+         cprintf("\nInside exec() , allocuvm being called with newsz=%d\n" , ph.vaddr + ph.memsz);
+         //------------------------------------------------------------------------
+         
+         goto bad;
+    }
+      
     if(ph.vaddr % PGSIZE != 0)
       goto bad;
     if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
@@ -63,8 +73,14 @@ exec(char *path, char **argv)
   // Allocate two pages at the next page boundary.
   // Make the first inaccessible.  Use the second as the user stack.
   sz = PGROUNDUP(sz);
-  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
+  
+  if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0){
+      //-----------------------------added by afnan-------------------------
+  cprintf("\nInside exec() , allocuvm being called 2nd time with newsz=%d\n" , sz + 2*PGSIZE);
+  //--------------------------------------------------------------------
     goto bad;
+  }
+    
   clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
   sp = sz;
 
@@ -99,6 +115,13 @@ exec(char *path, char **argv)
   curproc->sz = sz;
   curproc->tf->eip = elf.entry;  // main
   curproc->tf->esp = sp;
+
+  //---------------added bu user------------------------
+  //for building new image of curr proc
+  removeSwapFile(myproc());
+  createSwapFile(myproc());
+  //-----------------------------------------------------
+
   switchuvm(curproc);
   freevm(oldpgdir);
   return 0;
diff --git a/fcntl.h b/fcntl.h
old mode 100644
new mode 100755
diff --git a/file.c b/file.c
old mode 100644
new mode 100755
diff --git a/file.h b/file.h
old mode 100644
new mode 100755
diff --git a/forktest.c b/forktest.c
old mode 100644
new mode 100755
diff --git a/fs.c b/fs.c
old mode 100644
new mode 100755
index f77275f..803a783
--- a/fs.c
+++ b/fs.c
@@ -668,3 +668,144 @@ nameiparent(char *path, char *name)
 {
   return namex(path, 1, name);
 }
+
+// NEW FOR PAGING
+
+#include "fcntl.h"
+#define DIGITS 14
+
+char* itoa(int i, char b[]){
+    char const digit[] = "0123456789";
+    char* p = b;
+    if(i<0){
+        *p++ = '-';
+        i *= -1;
+    }
+    int shifter = i;
+    do{ //Move to where representation ends
+        ++p;
+        shifter = shifter/10;
+    }while(shifter);
+    *p = '\0';
+    do{ //Move back, inserting digits as u go
+        *--p = digit[i%10];
+        i = i/10;
+    }while(i);
+    return b;
+}
+
+//remove swap file of proc p;
+int
+removeSwapFile(struct proc* p)
+{
+	//path of proccess
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+	struct inode *ip, *dp;
+	struct dirent de;
+	char name[DIRSIZ];
+	uint off;
+
+	if(0 == p->swapFile)
+	{
+		return -1;
+	}
+	fileclose(p->swapFile);
+
+	begin_op();
+	if((dp = nameiparent(path, name)) == 0)
+	{
+		end_op();
+		return -1;
+	}
+
+	ilock(dp);
+
+	  // Cannot unlink "." or "..".
+	if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+	   goto bad;
+
+	if((ip = dirlookup(dp, name, &off)) == 0)
+		goto bad;
+	ilock(ip);
+
+	if(ip->nlink < 1)
+		panic("unlink: nlink < 1");
+	if(ip->type == T_DIR && !isdirempty(ip)){
+		iunlockput(ip);
+		goto bad;
+	}
+
+	memset(&de, 0, sizeof(de));
+	if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+		panic("unlink: writei");
+	if(ip->type == T_DIR){
+		dp->nlink--;
+		iupdate(dp);
+	}
+	iunlockput(dp);
+
+	ip->nlink--;
+	iupdate(ip);
+	iunlockput(ip);
+
+	end_op();
+
+	return 0;
+
+	bad:
+		iunlockput(dp);
+		end_op();
+		return -1;
+
+}
+
+
+//return 0 on success
+int
+createSwapFile(struct proc* p)
+{
+
+	char path[DIGITS];
+	memmove(path,"/.swap", 6);
+	itoa(p->pid, path+ 6);
+
+    begin_op();
+    struct inode * in = create(path, T_FILE, 0, 0);
+	iunlock(in);
+
+	p->swapFile = filealloc();
+	if (p->swapFile == 0)
+		panic("no slot for files on /store");
+
+	p->swapFile->ip = in;
+	p->swapFile->type = FD_INODE;
+	p->swapFile->off = 0;
+	p->swapFile->readable = O_WRONLY;
+	p->swapFile->writable = O_RDWR;
+    end_op();
+  //cprintf("create swap file called for %s\n" , p->name);
+    return 0;
+}
+
+//return as sys_write (-1 when error)
+int
+writeToSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return filewrite(p->swapFile, buffer, size);
+
+}
+
+//return as sys_read (-1 when error)
+int
+readFromSwapFile(struct proc * p, char* buffer, uint placeOnFile, uint size)
+{
+	p->swapFile->off = placeOnFile;
+
+	return fileread(p->swapFile, buffer,  size);
+}
+
diff --git a/fs.c.orig b/fs.c.orig
new file mode 100755
index 0000000..f77275f
--- /dev/null
+++ b/fs.c.orig
@@ -0,0 +1,670 @@
+// File system implementation.  Five layers:
+//   + Blocks: allocator for raw disk blocks.
+//   + Log: crash recovery for multi-step updates.
+//   + Files: inode allocator, reading, writing, metadata.
+//   + Directories: inode with special contents (list of other inodes!)
+//   + Names: paths like /usr/rtm/xv6/fs.c for convenient naming.
+//
+// This file contains the low-level file system manipulation
+// routines.  The (higher-level) system call implementations
+// are in sysfile.c.
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "fs.h"
+#include "buf.h"
+#include "file.h"
+
+#define min(a, b) ((a) < (b) ? (a) : (b))
+static void itrunc(struct inode*);
+// there should be one superblock per disk device, but we run with
+// only one device
+struct superblock sb; 
+
+// Read the super block.
+void
+readsb(int dev, struct superblock *sb)
+{
+  struct buf *bp;
+
+  bp = bread(dev, 1);
+  memmove(sb, bp->data, sizeof(*sb));
+  brelse(bp);
+}
+
+// Zero a block.
+static void
+bzero(int dev, int bno)
+{
+  struct buf *bp;
+
+  bp = bread(dev, bno);
+  memset(bp->data, 0, BSIZE);
+  log_write(bp);
+  brelse(bp);
+}
+
+// Blocks.
+
+// Allocate a zeroed disk block.
+static uint
+balloc(uint dev)
+{
+  int b, bi, m;
+  struct buf *bp;
+
+  bp = 0;
+  for(b = 0; b < sb.size; b += BPB){
+    bp = bread(dev, BBLOCK(b, sb));
+    for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
+      m = 1 << (bi % 8);
+      if((bp->data[bi/8] & m) == 0){  // Is block free?
+        bp->data[bi/8] |= m;  // Mark block in use.
+        log_write(bp);
+        brelse(bp);
+        bzero(dev, b + bi);
+        return b + bi;
+      }
+    }
+    brelse(bp);
+  }
+  panic("balloc: out of blocks");
+}
+
+// Free a disk block.
+static void
+bfree(int dev, uint b)
+{
+  struct buf *bp;
+  int bi, m;
+
+  bp = bread(dev, BBLOCK(b, sb));
+  bi = b % BPB;
+  m = 1 << (bi % 8);
+  if((bp->data[bi/8] & m) == 0)
+    panic("freeing free block");
+  bp->data[bi/8] &= ~m;
+  log_write(bp);
+  brelse(bp);
+}
+
+// Inodes.
+//
+// An inode describes a single unnamed file.
+// The inode disk structure holds metadata: the file's type,
+// its size, the number of links referring to it, and the
+// list of blocks holding the file's content.
+//
+// The inodes are laid out sequentially on disk at
+// sb.startinode. Each inode has a number, indicating its
+// position on the disk.
+//
+// The kernel keeps a cache of in-use inodes in memory
+// to provide a place for synchronizing access
+// to inodes used by multiple processes. The cached
+// inodes include book-keeping information that is
+// not stored on disk: ip->ref and ip->valid.
+//
+// An inode and its in-memory representation go through a
+// sequence of states before they can be used by the
+// rest of the file system code.
+//
+// * Allocation: an inode is allocated if its type (on disk)
+//   is non-zero. ialloc() allocates, and iput() frees if
+//   the reference and link counts have fallen to zero.
+//
+// * Referencing in cache: an entry in the inode cache
+//   is free if ip->ref is zero. Otherwise ip->ref tracks
+//   the number of in-memory pointers to the entry (open
+//   files and current directories). iget() finds or
+//   creates a cache entry and increments its ref; iput()
+//   decrements ref.
+//
+// * Valid: the information (type, size, &c) in an inode
+//   cache entry is only correct when ip->valid is 1.
+//   ilock() reads the inode from
+//   the disk and sets ip->valid, while iput() clears
+//   ip->valid if ip->ref has fallen to zero.
+//
+// * Locked: file system code may only examine and modify
+//   the information in an inode and its content if it
+//   has first locked the inode.
+//
+// Thus a typical sequence is:
+//   ip = iget(dev, inum)
+//   ilock(ip)
+//   ... examine and modify ip->xxx ...
+//   iunlock(ip)
+//   iput(ip)
+//
+// ilock() is separate from iget() so that system calls can
+// get a long-term reference to an inode (as for an open file)
+// and only lock it for short periods (e.g., in read()).
+// The separation also helps avoid deadlock and races during
+// pathname lookup. iget() increments ip->ref so that the inode
+// stays cached and pointers to it remain valid.
+//
+// Many internal file system functions expect the caller to
+// have locked the inodes involved; this lets callers create
+// multi-step atomic operations.
+//
+// The icache.lock spin-lock protects the allocation of icache
+// entries. Since ip->ref indicates whether an entry is free,
+// and ip->dev and ip->inum indicate which i-node an entry
+// holds, one must hold icache.lock while using any of those fields.
+//
+// An ip->lock sleep-lock protects all ip-> fields other than ref,
+// dev, and inum.  One must hold ip->lock in order to
+// read or write that inode's ip->valid, ip->size, ip->type, &c.
+
+struct {
+  struct spinlock lock;
+  struct inode inode[NINODE];
+} icache;
+
+void
+iinit(int dev)
+{
+  int i = 0;
+  
+  initlock(&icache.lock, "icache");
+  for(i = 0; i < NINODE; i++) {
+    initsleeplock(&icache.inode[i].lock, "inode");
+  }
+
+  readsb(dev, &sb);
+  cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
+ inodestart %d bmap start %d\n", sb.size, sb.nblocks,
+          sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
+          sb.bmapstart);
+}
+
+static struct inode* iget(uint dev, uint inum);
+
+//PAGEBREAK!
+// Allocate an inode on device dev.
+// Mark it as allocated by  giving it type type.
+// Returns an unlocked but allocated and referenced inode.
+struct inode*
+ialloc(uint dev, short type)
+{
+  int inum;
+  struct buf *bp;
+  struct dinode *dip;
+
+  for(inum = 1; inum < sb.ninodes; inum++){
+    bp = bread(dev, IBLOCK(inum, sb));
+    dip = (struct dinode*)bp->data + inum%IPB;
+    if(dip->type == 0){  // a free inode
+      memset(dip, 0, sizeof(*dip));
+      dip->type = type;
+      log_write(bp);   // mark it allocated on the disk
+      brelse(bp);
+      return iget(dev, inum);
+    }
+    brelse(bp);
+  }
+  panic("ialloc: no inodes");
+}
+
+// Copy a modified in-memory inode to disk.
+// Must be called after every change to an ip->xxx field
+// that lives on disk, since i-node cache is write-through.
+// Caller must hold ip->lock.
+void
+iupdate(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+  dip = (struct dinode*)bp->data + ip->inum%IPB;
+  dip->type = ip->type;
+  dip->major = ip->major;
+  dip->minor = ip->minor;
+  dip->nlink = ip->nlink;
+  dip->size = ip->size;
+  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
+  log_write(bp);
+  brelse(bp);
+}
+
+// Find the inode with number inum on device dev
+// and return the in-memory copy. Does not lock
+// the inode and does not read it from disk.
+static struct inode*
+iget(uint dev, uint inum)
+{
+  struct inode *ip, *empty;
+
+  acquire(&icache.lock);
+
+  // Is the inode already cached?
+  empty = 0;
+  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
+    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
+      ip->ref++;
+      release(&icache.lock);
+      return ip;
+    }
+    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
+      empty = ip;
+  }
+
+  // Recycle an inode cache entry.
+  if(empty == 0)
+    panic("iget: no inodes");
+
+  ip = empty;
+  ip->dev = dev;
+  ip->inum = inum;
+  ip->ref = 1;
+  ip->valid = 0;
+  release(&icache.lock);
+
+  return ip;
+}
+
+// Increment reference count for ip.
+// Returns ip to enable ip = idup(ip1) idiom.
+struct inode*
+idup(struct inode *ip)
+{
+  acquire(&icache.lock);
+  ip->ref++;
+  release(&icache.lock);
+  return ip;
+}
+
+// Lock the given inode.
+// Reads the inode from disk if necessary.
+void
+ilock(struct inode *ip)
+{
+  struct buf *bp;
+  struct dinode *dip;
+
+  if(ip == 0 || ip->ref < 1)
+    panic("ilock");
+
+  acquiresleep(&ip->lock);
+
+  if(ip->valid == 0){
+    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
+    dip = (struct dinode*)bp->data + ip->inum%IPB;
+    ip->type = dip->type;
+    ip->major = dip->major;
+    ip->minor = dip->minor;
+    ip->nlink = dip->nlink;
+    ip->size = dip->size;
+    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
+    brelse(bp);
+    ip->valid = 1;
+    if(ip->type == 0)
+      panic("ilock: no type");
+  }
+}
+
+// Unlock the given inode.
+void
+iunlock(struct inode *ip)
+{
+  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
+    panic("iunlock");
+
+  releasesleep(&ip->lock);
+}
+
+// Drop a reference to an in-memory inode.
+// If that was the last reference, the inode cache entry can
+// be recycled.
+// If that was the last reference and the inode has no links
+// to it, free the inode (and its content) on disk.
+// All calls to iput() must be inside a transaction in
+// case it has to free the inode.
+void
+iput(struct inode *ip)
+{
+  acquiresleep(&ip->lock);
+  if(ip->valid && ip->nlink == 0){
+    acquire(&icache.lock);
+    int r = ip->ref;
+    release(&icache.lock);
+    if(r == 1){
+      // inode has no links and no other references: truncate and free.
+      itrunc(ip);
+      ip->type = 0;
+      iupdate(ip);
+      ip->valid = 0;
+    }
+  }
+  releasesleep(&ip->lock);
+
+  acquire(&icache.lock);
+  ip->ref--;
+  release(&icache.lock);
+}
+
+// Common idiom: unlock, then put.
+void
+iunlockput(struct inode *ip)
+{
+  iunlock(ip);
+  iput(ip);
+}
+
+//PAGEBREAK!
+// Inode content
+//
+// The content (data) associated with each inode is stored
+// in blocks on the disk. The first NDIRECT block numbers
+// are listed in ip->addrs[].  The next NINDIRECT blocks are
+// listed in block ip->addrs[NDIRECT].
+
+// Return the disk block address of the nth block in inode ip.
+// If there is no such block, bmap allocates one.
+static uint
+bmap(struct inode *ip, uint bn)
+{
+  uint addr, *a;
+  struct buf *bp;
+
+  if(bn < NDIRECT){
+    if((addr = ip->addrs[bn]) == 0)
+      ip->addrs[bn] = addr = balloc(ip->dev);
+    return addr;
+  }
+  bn -= NDIRECT;
+
+  if(bn < NINDIRECT){
+    // Load indirect block, allocating if necessary.
+    if((addr = ip->addrs[NDIRECT]) == 0)
+      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
+    bp = bread(ip->dev, addr);
+    a = (uint*)bp->data;
+    if((addr = a[bn]) == 0){
+      a[bn] = addr = balloc(ip->dev);
+      log_write(bp);
+    }
+    brelse(bp);
+    return addr;
+  }
+
+  panic("bmap: out of range");
+}
+
+// Truncate inode (discard contents).
+// Only called when the inode has no links
+// to it (no directory entries referring to it)
+// and has no in-memory reference to it (is
+// not an open file or current directory).
+static void
+itrunc(struct inode *ip)
+{
+  int i, j;
+  struct buf *bp;
+  uint *a;
+
+  for(i = 0; i < NDIRECT; i++){
+    if(ip->addrs[i]){
+      bfree(ip->dev, ip->addrs[i]);
+      ip->addrs[i] = 0;
+    }
+  }
+
+  if(ip->addrs[NDIRECT]){
+    bp = bread(ip->dev, ip->addrs[NDIRECT]);
+    a = (uint*)bp->data;
+    for(j = 0; j < NINDIRECT; j++){
+      if(a[j])
+        bfree(ip->dev, a[j]);
+    }
+    brelse(bp);
+    bfree(ip->dev, ip->addrs[NDIRECT]);
+    ip->addrs[NDIRECT] = 0;
+  }
+
+  ip->size = 0;
+  iupdate(ip);
+}
+
+// Copy stat information from inode.
+// Caller must hold ip->lock.
+void
+stati(struct inode *ip, struct stat *st)
+{
+  st->dev = ip->dev;
+  st->ino = ip->inum;
+  st->type = ip->type;
+  st->nlink = ip->nlink;
+  st->size = ip->size;
+}
+
+//PAGEBREAK!
+// Read data from inode.
+// Caller must hold ip->lock.
+int
+readi(struct inode *ip, char *dst, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
+      return -1;
+    return devsw[ip->major].read(ip, dst, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > ip->size)
+    n = ip->size - off;
+
+  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(dst, bp->data + off%BSIZE, m);
+    brelse(bp);
+  }
+  return n;
+}
+
+// PAGEBREAK!
+// Write data to inode.
+// Caller must hold ip->lock.
+int
+writei(struct inode *ip, char *src, uint off, uint n)
+{
+  uint tot, m;
+  struct buf *bp;
+
+  if(ip->type == T_DEV){
+    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
+      return -1;
+    return devsw[ip->major].write(ip, src, n);
+  }
+
+  if(off > ip->size || off + n < off)
+    return -1;
+  if(off + n > MAXFILE*BSIZE)
+    return -1;
+
+  for(tot=0; tot<n; tot+=m, off+=m, src+=m){
+    bp = bread(ip->dev, bmap(ip, off/BSIZE));
+    m = min(n - tot, BSIZE - off%BSIZE);
+    memmove(bp->data + off%BSIZE, src, m);
+    log_write(bp);
+    brelse(bp);
+  }
+
+  if(n > 0 && off > ip->size){
+    ip->size = off;
+    iupdate(ip);
+  }
+  return n;
+}
+
+//PAGEBREAK!
+// Directories
+
+int
+namecmp(const char *s, const char *t)
+{
+  return strncmp(s, t, DIRSIZ);
+}
+
+// Look for a directory entry in a directory.
+// If found, set *poff to byte offset of entry.
+struct inode*
+dirlookup(struct inode *dp, char *name, uint *poff)
+{
+  uint off, inum;
+  struct dirent de;
+
+  if(dp->type != T_DIR)
+    panic("dirlookup not DIR");
+
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlookup read");
+    if(de.inum == 0)
+      continue;
+    if(namecmp(name, de.name) == 0){
+      // entry matches path element
+      if(poff)
+        *poff = off;
+      inum = de.inum;
+      return iget(dp->dev, inum);
+    }
+  }
+
+  return 0;
+}
+
+// Write a new directory entry (name, inum) into the directory dp.
+int
+dirlink(struct inode *dp, char *name, uint inum)
+{
+  int off;
+  struct dirent de;
+  struct inode *ip;
+
+  // Check that name is not present.
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iput(ip);
+    return -1;
+  }
+
+  // Look for an empty dirent.
+  for(off = 0; off < dp->size; off += sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("dirlink read");
+    if(de.inum == 0)
+      break;
+  }
+
+  strncpy(de.name, name, DIRSIZ);
+  de.inum = inum;
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("dirlink");
+
+  return 0;
+}
+
+//PAGEBREAK!
+// Paths
+
+// Copy the next path element from path into name.
+// Return a pointer to the element following the copied one.
+// The returned path has no leading slashes,
+// so the caller can check *path=='\0' to see if the name is the last one.
+// If no name to remove, return 0.
+//
+// Examples:
+//   skipelem("a/bb/c", name) = "bb/c", setting name = "a"
+//   skipelem("///a//bb", name) = "bb", setting name = "a"
+//   skipelem("a", name) = "", setting name = "a"
+//   skipelem("", name) = skipelem("////", name) = 0
+//
+static char*
+skipelem(char *path, char *name)
+{
+  char *s;
+  int len;
+
+  while(*path == '/')
+    path++;
+  if(*path == 0)
+    return 0;
+  s = path;
+  while(*path != '/' && *path != 0)
+    path++;
+  len = path - s;
+  if(len >= DIRSIZ)
+    memmove(name, s, DIRSIZ);
+  else {
+    memmove(name, s, len);
+    name[len] = 0;
+  }
+  while(*path == '/')
+    path++;
+  return path;
+}
+
+// Look up and return the inode for a path name.
+// If parent != 0, return the inode for the parent and copy the final
+// path element into name, which must have room for DIRSIZ bytes.
+// Must be called inside a transaction since it calls iput().
+static struct inode*
+namex(char *path, int nameiparent, char *name)
+{
+  struct inode *ip, *next;
+
+  if(*path == '/')
+    ip = iget(ROOTDEV, ROOTINO);
+  else
+    ip = idup(myproc()->cwd);
+
+  while((path = skipelem(path, name)) != 0){
+    ilock(ip);
+    if(ip->type != T_DIR){
+      iunlockput(ip);
+      return 0;
+    }
+    if(nameiparent && *path == '\0'){
+      // Stop one level early.
+      iunlock(ip);
+      return ip;
+    }
+    if((next = dirlookup(ip, name, 0)) == 0){
+      iunlockput(ip);
+      return 0;
+    }
+    iunlockput(ip);
+    ip = next;
+  }
+  if(nameiparent){
+    iput(ip);
+    return 0;
+  }
+  return ip;
+}
+
+struct inode*
+namei(char *path)
+{
+  char name[DIRSIZ];
+  return namex(path, 0, name);
+}
+
+struct inode*
+nameiparent(char *path, char *name)
+{
+  return namex(path, 1, name);
+}
diff --git a/fs.h b/fs.h
old mode 100644
new mode 100755
diff --git a/gdbutil b/gdbutil
old mode 100644
new mode 100755
diff --git a/grep.c b/grep.c
old mode 100644
new mode 100755
diff --git a/ide.c b/ide.c
old mode 100644
new mode 100755
diff --git a/init.c b/init.c
old mode 100644
new mode 100755
diff --git a/initcode.S b/initcode.S
old mode 100644
new mode 100755
diff --git a/ioapic.c b/ioapic.c
old mode 100644
new mode 100755
diff --git a/kalloc.c b/kalloc.c
old mode 100644
new mode 100755
diff --git a/kbd.c b/kbd.c
old mode 100644
new mode 100755
diff --git a/kbd.h b/kbd.h
old mode 100644
new mode 100755
diff --git a/kernel.ld b/kernel.ld
old mode 100644
new mode 100755
diff --git a/kill.c b/kill.c
old mode 100644
new mode 100755
diff --git a/lapic.c b/lapic.c
old mode 100644
new mode 100755
diff --git a/ln.c b/ln.c
old mode 100644
new mode 100755
diff --git a/log.c b/log.c
old mode 100644
new mode 100755
diff --git a/ls.c b/ls.c
old mode 100644
new mode 100755
diff --git a/main.c b/main.c
old mode 100644
new mode 100755
diff --git a/memide.c b/memide.c
old mode 100644
new mode 100755
diff --git a/memlayout.h b/memlayout.h
old mode 100644
new mode 100755
diff --git a/mkdir.c b/mkdir.c
old mode 100644
new mode 100755
diff --git a/mkfs.c b/mkfs.c
old mode 100644
new mode 100755
diff --git a/mmu.h b/mmu.h
old mode 100644
new mode 100755
index a82d8e2..4544bba
--- a/mmu.h
+++ b/mmu.h
@@ -95,6 +95,13 @@ struct segdesc {
 #define PTE_W           0x002   // Writeable
 #define PTE_U           0x004   // User
 #define PTE_PS          0x080   // Page Size
+#define PTE_A           0x020   // Accessed (R bit for NRU)
+#define PTE_PG          0x200   // Paged out to secondary storage
+#define PTE_M           0x040   // Dirty bit (M bit for NRU)
+
+//-----------------added by afnan--------------------------
+//#define NRU 1 //set to 1 for using NRU instead of FIFO
+//---------------------------------------------------------
 
 // Address in page table or page directory entry
 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
diff --git a/mp.c b/mp.c
old mode 100644
new mode 100755
diff --git a/mp.h b/mp.h
old mode 100644
new mode 100755
diff --git a/param.h b/param.h
old mode 100644
new mode 100755
diff --git a/picirq.c b/picirq.c
old mode 100644
new mode 100755
diff --git a/pipe.c b/pipe.c
old mode 100644
new mode 100755
diff --git a/printf.c b/printf.c
old mode 100644
new mode 100755
diff --git a/proc.c b/proc.c
old mode 100644
new mode 100755
index 806b1b1..1c89635
--- a/proc.c
+++ b/proc.c
@@ -20,10 +20,95 @@ extern void trapret(void);
 
 static void wakeup1(void *chan);
 
+//-----------------------added by afnan---------------------------
+void initNewFeatures(struct proc *p)
+{
+  cprintf("Initializing new features inside allocproc\n");
+  p->pageFaultCount = 0;
+  p->pagesInMemory = 0;
+  p->pagesInSwapFile = 0;
+  p->headOfQueueIdx = -1;
+
+  int i;
+  for (i = 0; i < MAX_PSYC_PAGES ; i++) {
+      p->memPageArray[i].virtual_Address = (char*)0xffffffff;
+      p->memPageArray[i].used = 0;
+      p->memPageArray[i].nextIdx = -1;
+
+      p->swapPageArray[i].virtual_Address = (char*)0xffffffff;
+      p->swapPageArray[i].used = 0;
+  }
+}
+
+int not_init_or_sh(struct proc *p){
+  if (strncmp(p->name, "init" , 4) != 0 && strncmp(p->name, "sh" , 2) != 0){
+    return 1;
+  }
+  return 0;
+}
+
+void copySwapFile(struct proc *child , struct proc *parent){
+  char buf[PGSIZE/2];
+
+  for(int i=0; i<MAX_PSYC_PAGES; i++){
+    if(parent->swapPageArray[i].used){
+        readFromSwapFile(parent, buf, i*PGSIZE, PGSIZE/2);
+        writeToSwapFile(child, buf, i*PGSIZE, PGSIZE/2);
+
+        readFromSwapFile(parent, buf, i*PGSIZE+PGSIZE/2, PGSIZE/2);
+        writeToSwapFile(child, buf, i*PGSIZE+PGSIZE/2, PGSIZE/2);
+    }
+  }
+}
+
+void copyParentToChild(struct proc *child , struct proc *parent){
+  
+  if(parent->swapFile==0 || strncmp(parent->name, "init", 4)==0 ){
+    return;
+  }
+
+  child->pagesInMemory = parent->pagesInMemory;
+  child->pageFaultCount = parent->pageFaultCount;
+  child->pagesInSwapFile = parent->pagesInSwapFile;
+
+  for (int i=0; i<MAX_PSYC_PAGES; i++){
+    child->memPageArray[i].virtual_Address = parent->memPageArray[i].virtual_Address;
+    child->memPageArray[i].used = parent->memPageArray[i].used;
+    child->memPageArray[i].nextIdx = parent->memPageArray[i].nextIdx;
+
+    child->swapPageArray[i].virtual_Address = parent->swapPageArray[i].virtual_Address;
+    child->swapPageArray[i].used = parent->swapPageArray[i].used;
+
+  }
+  
+  createSwapFile(child);
+  copySwapFile(child , parent);
+}
+//----------------------------------------------------------------
+
+
 void
 pinit(void)
 {
   initlock(&ptable.lock, "ptable");
+  //-------------------added by afnan------------------------------
+  for(int j=0; j<NPROC; j++){
+    ptable.proc[j].swapFile=0;
+    ptable.proc[j].pagesInMemory = 0;
+    ptable.proc[j].pagesInSwapFile = 0;
+    ptable.proc[j].pageFaultCount = 0;
+    ptable.proc[j].headOfQueueIdx = -1;
+
+    for (int i=0; i<MAX_PSYC_PAGES; i++){
+      ptable.proc[j].memPageArray[i].virtual_Address = (char*)0xffffffff;
+      ptable.proc[j].memPageArray[i].used = 0;
+      ptable.proc[j].memPageArray[i].nextIdx = -1;
+
+      ptable.proc[j].swapPageArray[i].virtual_Address = (char*)0xffffffff;
+      ptable.proc[j].swapPageArray[i].used = 0;
+    }
+  }
+  //---------------------------------------------------------------
 }
 
 // Must be called with interrupts disabled
@@ -112,6 +197,10 @@ found:
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
 
+  //-----------------------added by afnan---------------------------
+  initNewFeatures(p);
+  //----------------------------------------------------------------
+
   return p;
 }
 
@@ -163,11 +252,17 @@ growproc(int n)
 
   sz = curproc->sz;
   if(n > 0){
-    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
+    
+    if((sz = allocuvm(curproc->pgdir, sz, sz + n)) == 0){
+         cprintf("Inside growproc(%d) , allocuvm being called with newsz=%d\n" , n , sz+n);
+         return -1;
+    }
+      
   } else if(n < 0){
-    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0)
-      return -1;
+    if((sz = deallocuvm(curproc->pgdir, sz, sz + n)) == 0){
+         cprintf("Inside growproc(%d) , Deallocuvm being called with newsz=%d\n" , n , sz+n);
+         return -1;
+    }
   }
   curproc->sz = sz;
   switchuvm(curproc);
@@ -210,8 +305,12 @@ fork(void)
 
   safestrcpy(np->name, curproc->name, sizeof(curproc->name));
 
+  //-----------------------added by afnan---------------------------
+  copyParentToChild(np , curproc);
+  //----------------------------------------------------------------
+  
   pid = np->pid;
-
+  
   acquire(&ptable.lock);
 
   np->state = RUNNABLE;
@@ -242,10 +341,23 @@ exit(void)
     }
   }
 
+
   begin_op();
   iput(curproc->cwd);
   end_op();
   curproc->cwd = 0;
+//-----------------------added by afnan---------------------------
+ 
+  if(curproc->swapFile!=0){   //removing swap file if available
+    if (removeSwapFile(curproc) != 0){
+        panic("Error in exit.Couldn't deleting swap file\n");
+    }else{
+        curproc->swapFile=0;
+    }
+    
+  }
+  
+//--------------------------------------------------  --------------
 
   acquire(&ptable.lock);
 
@@ -323,22 +435,24 @@ void
 scheduler(void)
 {
   struct proc *p;
+  int ran;
   struct cpu *c = mycpu();
   c->proc = 0;
-  
+
   for(;;){
     // Enable interrupts on this processor.
     sti();
 
     // Loop over process table looking for process to run.
     acquire(&ptable.lock);
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    for(ran = 0, p = ptable.proc; p < &ptable.proc[NPROC]; p++){
       if(p->state != RUNNABLE)
         continue;
 
       // Switch to chosen process.  It is the process's job
       // to release ptable.lock and then reacquire it
       // before jumping back to us.
+      ran = 1;
       c->proc = p;
       switchuvm(p);
       p->state = RUNNING;
@@ -349,9 +463,14 @@ scheduler(void)
       // Process is done running for now.
       // It should have changed its p->state before coming back.
       c->proc = 0;
+
+
     }
     release(&ptable.lock);
 
+    if (ran == 0) {
+      halt();
+    }
   }
 }
 
@@ -511,7 +630,7 @@ procdump(void)
   [RUNNING]   "run   ",
   [ZOMBIE]    "zombie"
   };
-  int i;
+  int i,j;
   struct proc *p;
   char *state;
   uint pc[10];
@@ -530,5 +649,119 @@ procdump(void)
         cprintf(" %p", pc[i]);
     }
     cprintf("\n");
+    //-----------------------added by afnan-----------------------------
+    int k;
+    cprintf("Page Tables:\n\tMemory Location of Page Directory: %d\n" , V2P(p->pgdir));
+    for(j=0 ; j<=NPTENTRIES/2; j++){
+      if(((p->pgdir[j] & PTE_P) != 0) && ((p->pgdir[j] & PTE_U) != 0)){
+        int ppn = p->pgdir[j]>>PTXSHIFT;
+        cprintf("pdir PTE %d, %d\n\tmemory location of page table = %d\n" , j , ppn , ppn<<PTXSHIFT);
+        
+        pde_t* pde = &p->pgdir[j];
+        pte_t* pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+        //printing page table entries
+        for(k=0;k<=NPTENTRIES/2;k++){
+          if((pgtab[k] & PTE_U) != 0){
+            if((pgtab[k] & PTE_P) != 0){
+              cprintf("ptbl PTE %d, %d , %d\n" , k , pgtab[k]>>PTXSHIFT , pgtab[k]);
+            }
+          }
+        }
+      }
+    }
+    int va , pa;
+    cprintf("Page Mappings\n");
+    for(int i=0 ; i<NPTENTRIES/2 ; i++){
+      if(((p->pgdir[i] & PTE_P) != 0) && ((p->pgdir[i] & PTE_U) != 0)){
+          pde_t* pde = &p->pgdir[i];
+          pte_t* pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+          for(int j = 0 ; j<NPTENTRIES/2 ; j++){
+            va = (i<<10)|j ;
+            if((pgtab[j] & PTE_U) != 0){
+              if((pgtab[j] & PTE_P) != 0){
+                 pa = pgtab[j]>>12;
+                 cprintf("Virtual Address : %d => Physical Address : %d\n" , va , pa);
+             }
+          } 
+        }
+      }
+    }
+    //---------------------------------------------------------------------
+
+
   }
+
 }
+
+/*
+
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    lcr3(V2P(myproc()->pgdir));
+  }
+  return &pgtab[PTX(va)];
+}
+
+*/
+
+void reset_R(){
+      struct proc *p;
+      cprintf("NRU : resetting R flag\n");
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+        
+          for(int i=0 ; i<NPTENTRIES ; i++){
+            if(((p->pgdir[i] & PTE_P) != 0)){
+                 pde_t* pde = &p->pgdir[i];
+                 cprintf("dhuksi--");
+                 pte_t* pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+                 cprintf("dhuksi-");
+                 for(int j = 0 ; j<NPTENTRIES ; j++){
+                 cprintf("dhuksi");
+                 if((pgtab[j] & PTE_U) != 0){
+                   if((pgtab[j] & PTE_P) != 0){
+                      pgtab[j] &= (~PTE_A);
+                      cprintf("dhuksi");
+                }
+              }         
+           }
+         }
+           
+          
+          /*
+          cprintf("ptable luper vitre\n");
+          pte_t *pte_nru=0;
+          for(int i=0; i<MAX_PSYC_PAGES ; i++){
+              cprintf("dhuksi");
+              if(p->state != UNUSED) pte_nru = walkpgdir(p->pgdir , p->memPageArray[i].virtual_Address , 0);
+              cprintf("%d\n" , *pte_nru);
+              *pte_nru =(*pte_nru) & (~PTE_A);
+              cprintf("ptbl luper vitre\n");
+          }
+          */        
+      }
+      }
+}
+
+
+
+//template to wrap newly added code
+
+//-----------------------added by afnan---------------------------
+
+//----------------------------------------------------------------
\ No newline at end of file
diff --git a/proc.h b/proc.h
old mode 100644
new mode 100755
index 1647114..89f6f37
--- a/proc.h
+++ b/proc.h
@@ -1,3 +1,16 @@
+//---------------added by afnan-------------
+#define MAX_PSYC_PAGES 15
+#define MAX_TOTAL_PAGES 30
+
+
+struct pageInfo{
+    char* virtual_Address;                  
+    int used;           
+    int nextIdx;
+};
+
+//------------------------------------------
+
 // Per-CPU state
 struct cpu {
   uchar apicid;                // Local APIC ID
@@ -49,6 +62,17 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  //Swap file. must initiate with create swap file
+  struct file *swapFile;			//page file
+
+  //-------------------added by afnan--------------------------
+  int pagesInMemory;      
+  int pagesInSwapFile;
+  int pageFaultCount;
+  int headOfQueueIdx; 
+  struct pageInfo memPageArray[MAX_PSYC_PAGES];  
+  struct pageInfo swapPageArray[MAX_PSYC_PAGES];
+  //-----------------------------------------------------------
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff --git a/rm.c b/rm.c
old mode 100644
new mode 100755
diff --git a/runoff.list b/runoff.list
old mode 100644
new mode 100755
diff --git a/runoff.spec b/runoff.spec
old mode 100644
new mode 100755
diff --git a/sh.c b/sh.c
old mode 100644
new mode 100755
index 054bab9..b949dd8
--- a/sh.c
+++ b/sh.c
@@ -75,6 +75,7 @@ runcmd(struct cmd *cmd)
     ecmd = (struct execcmd*)cmd;
     if(ecmd->argv[0] == 0)
       exit();
+    //printf(1,"BEFORE EXEC\n\n");
     exec(ecmd->argv[0], ecmd->argv);
     printf(2, "exec %s failed\n", ecmd->argv[0]);
     break;
diff --git a/sleep1.p b/sleep1.p
old mode 100644
new mode 100755
diff --git a/sleeplock.c b/sleeplock.c
old mode 100644
new mode 100755
diff --git a/sleeplock.h b/sleeplock.h
old mode 100644
new mode 100755
diff --git a/spinlock.c b/spinlock.c
old mode 100644
new mode 100755
diff --git a/spinlock.h b/spinlock.h
old mode 100644
new mode 100755
diff --git a/stat.h b/stat.h
old mode 100644
new mode 100755
diff --git a/stressfs.c b/stressfs.c
old mode 100644
new mode 100755
diff --git a/string.c b/string.c
old mode 100644
new mode 100755
diff --git a/swtch.S b/swtch.S
old mode 100644
new mode 100755
diff --git a/syscall.c b/syscall.c
old mode 100644
new mode 100755
diff --git a/syscall.h b/syscall.h
old mode 100644
new mode 100755
diff --git a/sysfile.c b/sysfile.c
old mode 100644
new mode 100755
index bfe61b7..bf3848e
--- a/sysfile.c
+++ b/sysfile.c
@@ -165,7 +165,7 @@ bad:
 }
 
 // Is the directory dp empty except for "." and ".." ?
-static int
+int
 isdirempty(struct inode *dp)
 {
   int off;
@@ -238,7 +238,7 @@ bad:
   return -1;
 }
 
-static struct inode*
+struct inode*
 create(char *path, short type, short major, short minor)
 {
   struct inode *ip, *dp;
diff --git a/sysfile.c.orig b/sysfile.c.orig
new file mode 100755
index 0000000..bfe61b7
--- /dev/null
+++ b/sysfile.c.orig
@@ -0,0 +1,444 @@
+//
+// File-system system calls.
+// Mostly argument checking, since we don't trust
+// user code, and calls into file.c and fs.c.
+//
+
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "stat.h"
+#include "mmu.h"
+#include "proc.h"
+#include "fs.h"
+#include "spinlock.h"
+#include "sleeplock.h"
+#include "file.h"
+#include "fcntl.h"
+
+// Fetch the nth word-sized system call argument as a file descriptor
+// and return both the descriptor and the corresponding struct file.
+static int
+argfd(int n, int *pfd, struct file **pf)
+{
+  int fd;
+  struct file *f;
+
+  if(argint(n, &fd) < 0)
+    return -1;
+  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
+    return -1;
+  if(pfd)
+    *pfd = fd;
+  if(pf)
+    *pf = f;
+  return 0;
+}
+
+// Allocate a file descriptor for the given file.
+// Takes over file reference from caller on success.
+static int
+fdalloc(struct file *f)
+{
+  int fd;
+  struct proc *curproc = myproc();
+
+  for(fd = 0; fd < NOFILE; fd++){
+    if(curproc->ofile[fd] == 0){
+      curproc->ofile[fd] = f;
+      return fd;
+    }
+  }
+  return -1;
+}
+
+int
+sys_dup(void)
+{
+  struct file *f;
+  int fd;
+
+  if(argfd(0, 0, &f) < 0)
+    return -1;
+  if((fd=fdalloc(f)) < 0)
+    return -1;
+  filedup(f);
+  return fd;
+}
+
+int
+sys_read(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return fileread(f, p, n);
+}
+
+int
+sys_write(void)
+{
+  struct file *f;
+  int n;
+  char *p;
+
+  if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
+    return -1;
+  return filewrite(f, p, n);
+}
+
+int
+sys_close(void)
+{
+  int fd;
+  struct file *f;
+
+  if(argfd(0, &fd, &f) < 0)
+    return -1;
+  myproc()->ofile[fd] = 0;
+  fileclose(f);
+  return 0;
+}
+
+int
+sys_fstat(void)
+{
+  struct file *f;
+  struct stat *st;
+
+  if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
+    return -1;
+  return filestat(f, st);
+}
+
+// Create the path new as a link to the same inode as old.
+int
+sys_link(void)
+{
+  char name[DIRSIZ], *new, *old;
+  struct inode *dp, *ip;
+
+  if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
+    return -1;
+
+  begin_op();
+  if((ip = namei(old)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(ip);
+  if(ip->type == T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  ip->nlink++;
+  iupdate(ip);
+  iunlock(ip);
+
+  if((dp = nameiparent(new, name)) == 0)
+    goto bad;
+  ilock(dp);
+  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
+    iunlockput(dp);
+    goto bad;
+  }
+  iunlockput(dp);
+  iput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  ilock(ip);
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+  end_op();
+  return -1;
+}
+
+// Is the directory dp empty except for "." and ".." ?
+static int
+isdirempty(struct inode *dp)
+{
+  int off;
+  struct dirent de;
+
+  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
+    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+      panic("isdirempty: readi");
+    if(de.inum != 0)
+      return 0;
+  }
+  return 1;
+}
+
+//PAGEBREAK!
+int
+sys_unlink(void)
+{
+  struct inode *ip, *dp;
+  struct dirent de;
+  char name[DIRSIZ], *path;
+  uint off;
+
+  if(argstr(0, &path) < 0)
+    return -1;
+
+  begin_op();
+  if((dp = nameiparent(path, name)) == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(dp);
+
+  // Cannot unlink "." or "..".
+  if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
+    goto bad;
+
+  if((ip = dirlookup(dp, name, &off)) == 0)
+    goto bad;
+  ilock(ip);
+
+  if(ip->nlink < 1)
+    panic("unlink: nlink < 1");
+  if(ip->type == T_DIR && !isdirempty(ip)){
+    iunlockput(ip);
+    goto bad;
+  }
+
+  memset(&de, 0, sizeof(de));
+  if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
+    panic("unlink: writei");
+  if(ip->type == T_DIR){
+    dp->nlink--;
+    iupdate(dp);
+  }
+  iunlockput(dp);
+
+  ip->nlink--;
+  iupdate(ip);
+  iunlockput(ip);
+
+  end_op();
+
+  return 0;
+
+bad:
+  iunlockput(dp);
+  end_op();
+  return -1;
+}
+
+static struct inode*
+create(char *path, short type, short major, short minor)
+{
+  struct inode *ip, *dp;
+  char name[DIRSIZ];
+
+  if((dp = nameiparent(path, name)) == 0)
+    return 0;
+  ilock(dp);
+
+  if((ip = dirlookup(dp, name, 0)) != 0){
+    iunlockput(dp);
+    ilock(ip);
+    if(type == T_FILE && ip->type == T_FILE)
+      return ip;
+    iunlockput(ip);
+    return 0;
+  }
+
+  if((ip = ialloc(dp->dev, type)) == 0)
+    panic("create: ialloc");
+
+  ilock(ip);
+  ip->major = major;
+  ip->minor = minor;
+  ip->nlink = 1;
+  iupdate(ip);
+
+  if(type == T_DIR){  // Create . and .. entries.
+    dp->nlink++;  // for ".."
+    iupdate(dp);
+    // No ip->nlink++ for ".": avoid cyclic ref count.
+    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
+      panic("create dots");
+  }
+
+  if(dirlink(dp, name, ip->inum) < 0)
+    panic("create: dirlink");
+
+  iunlockput(dp);
+
+  return ip;
+}
+
+int
+sys_open(void)
+{
+  char *path;
+  int fd, omode;
+  struct file *f;
+  struct inode *ip;
+
+  if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
+    return -1;
+
+  begin_op();
+
+  if(omode & O_CREATE){
+    ip = create(path, T_FILE, 0, 0);
+    if(ip == 0){
+      end_op();
+      return -1;
+    }
+  } else {
+    if((ip = namei(path)) == 0){
+      end_op();
+      return -1;
+    }
+    ilock(ip);
+    if(ip->type == T_DIR && omode != O_RDONLY){
+      iunlockput(ip);
+      end_op();
+      return -1;
+    }
+  }
+
+  if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
+    if(f)
+      fileclose(f);
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  end_op();
+
+  f->type = FD_INODE;
+  f->ip = ip;
+  f->off = 0;
+  f->readable = !(omode & O_WRONLY);
+  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
+  return fd;
+}
+
+int
+sys_mkdir(void)
+{
+  char *path;
+  struct inode *ip;
+
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_mknod(void)
+{
+  struct inode *ip;
+  char *path;
+  int major, minor;
+
+  begin_op();
+  if((argstr(0, &path)) < 0 ||
+     argint(1, &major) < 0 ||
+     argint(2, &minor) < 0 ||
+     (ip = create(path, T_DEV, major, minor)) == 0){
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
+
+int
+sys_chdir(void)
+{
+  char *path;
+  struct inode *ip;
+  struct proc *curproc = myproc();
+  
+  begin_op();
+  if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
+    end_op();
+    return -1;
+  }
+  ilock(ip);
+  if(ip->type != T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+  iunlock(ip);
+  iput(curproc->cwd);
+  end_op();
+  curproc->cwd = ip;
+  return 0;
+}
+
+int
+sys_exec(void)
+{
+  char *path, *argv[MAXARG];
+  int i;
+  uint uargv, uarg;
+
+  if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
+    return -1;
+  }
+  memset(argv, 0, sizeof(argv));
+  for(i=0;; i++){
+    if(i >= NELEM(argv))
+      return -1;
+    if(fetchint(uargv+4*i, (int*)&uarg) < 0)
+      return -1;
+    if(uarg == 0){
+      argv[i] = 0;
+      break;
+    }
+    if(fetchstr(uarg, &argv[i]) < 0)
+      return -1;
+  }
+  return exec(path, argv);
+}
+
+int
+sys_pipe(void)
+{
+  int *fd;
+  struct file *rf, *wf;
+  int fd0, fd1;
+
+  if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
+    return -1;
+  if(pipealloc(&rf, &wf) < 0)
+    return -1;
+  fd0 = -1;
+  if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
+    if(fd0 >= 0)
+      myproc()->ofile[fd0] = 0;
+    fileclose(rf);
+    fileclose(wf);
+    return -1;
+  }
+  fd[0] = fd0;
+  fd[1] = fd1;
+  return 0;
+}
diff --git a/sysproc.c b/sysproc.c
old mode 100644
new mode 100755
diff --git a/test1.c b/test1.c
new file mode 100755
index 0000000..3c22acc
--- /dev/null
+++ b/test1.c
@@ -0,0 +1,42 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+void try1()
+{
+    int sz = 4096 * 17;
+    char *a = (char *)malloc(sz);
+
+    for (int i = 0; i < sz - 1; i++)
+    {
+        char ch = (i % 26) + 'a';
+        a[i] = ch;
+    }
+    sleep(250);
+    int flag = 1;
+
+    for (int i = 0; i < sz - 1; i++)
+    {
+        if (a[i] - 'a' != (i % 26))
+        {
+            printf(2, "Index i = %d , Failed\n", i);
+            flag = 0;
+            break;
+        }
+    }
+    if (!flag)
+    {
+        printf(2, "Failed!!!\n");
+    }
+    else
+    {
+        printf(2, "Success!!!!!!\n");
+    }
+    free((void *)a);
+}
+
+int main(int argc, char *argv[])
+{
+    try1();
+    exit();
+}
\ No newline at end of file
diff --git a/toc.ftr b/toc.ftr
old mode 100644
new mode 100755
diff --git a/toc.hdr b/toc.hdr
old mode 100644
new mode 100755
diff --git a/trap.c b/trap.c
old mode 100644
new mode 100755
index 41c66eb..cce9147
--- a/trap.c
+++ b/trap.c
@@ -8,12 +8,19 @@
 #include "traps.h"
 #include "spinlock.h"
 
+#define RED     "\x1b[31m"
+#define GREEN   "\x1b[32m"
+#define RESET   "\x1b[0m"
+
+
 // Interrupt descriptor table (shared by all CPUs).
 struct gatedesc idt[256];
 extern uint vectors[];  // in vectors.S: array of 256 entry pointers
 struct spinlock tickslock;
 uint ticks;
 
+int NRU = 0;
+
 void
 tvinit(void)
 {
@@ -31,7 +38,246 @@ idtinit(void)
 {
   lidt(idt, sizeof(idt));
 }
+//--------------------------added by afnan-------------------------
+
+
+static pte_t *
+walkpgdir(pde_t *pgdir, const void *va, int alloc)
+{
+  pde_t *pde;
+  pte_t *pgtab;
+
+  pde = &pgdir[PDX(va)];
+  if(*pde & PTE_P){
+    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
+  } else {
+    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
+      return 0;
+    // Make sure all those PTE_P bits are zero.
+    memset(pgtab, 0, PGSIZE);
+    // The permissions here are overly generous, but they can
+    // be further restricted by the permissions in the page table
+    // entries, if necessary.
+    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
+    lcr3(V2P(myproc()->pgdir));
+  }
+  return &pgtab[PTX(va)];
+}
+
+
+
+void print_page_fault_info(char* va){
+    cprintf(RED "\nT_PGFLT\n" RESET);
+    cprintf("rcr2 = %d\n", va);
+    va = (char*) PGROUNDDOWN((int)va);
+    cprintf("va = %d\n", va);
+}
+/*
+int move_swap_page_to_dummy_position(char* va , int *swapIdx , char* swapVa){
+    *swapIdx = -1;
+    for(int i=0; i<MAX_PSYC_PAGES ; i++){
+        if(myproc()->swapPageArray[i].virtual_Address == va && myproc()->swapPageArray[i].used==1){
+            *swapIdx = i;break;
+        }
+    }
+    if(*swapIdx == -1){
+      panic("Pagefault occured but page not found in swapFile\n");
+    }
+
+    swapVa = myproc()->swapPageArray[*swapIdx].virtual_Address;
+
+    int tmp_swapIdx = MAX_PSYC_PAGES;
+    for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+        if(myproc()->swapPageArray[i].virtual_Address == (char*)0xffffffff && myproc()->swapPageArray[i].used==0){
+            tmp_swapIdx = i;break;
+        }
+    }
+
+    char buffer[PGSIZE/4];
+
+    for(int i=0 ; i<4 ; i++){
+        readFromSwapFile(myproc(), buffer, (*swapIdx)*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+        writeToSwapFile(myproc(), buffer, tmp_swapIdx*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+    }
+
+    cprintf("Swap page moved to a dummy page slot\n");
+
+    return tmp_swapIdx;
+}
+*/
+void move_memPage_to_swapFile_NRU(int swapIdx){
+      int nruIdx = -1;
+      int found = 0;
+      //case 1 : not referenced and not modified
+      for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+          pte_t * pte_NRU = walkpgdir(myproc()->pgdir 
+                           , myproc()->memPageArray[i].virtual_Address , 0);
+          
+          if((*pte_NRU&PTE_A)==0 && (*pte_NRU&PTE_M)==0){
+              found=1;nruIdx = i;break;
+            }   
+      }
+      //case 2 : not referenced and modified
+      if(found == 0){
+          for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+          pte_t * pte_NRU = walkpgdir(myproc()->pgdir 
+                             , myproc()->memPageArray[i].virtual_Address , 0);
+          
+            if((*pte_NRU&PTE_A)==0 && (*pte_NRU&PTE_M)!=0){
+              found=1;nruIdx = i;break;
+            }   
+          } 
+      }
+      //case 3 : referenced and not modified
+      if(found == 0){
+          for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+              pte_t * pte_NRU = walkpgdir(myproc()->pgdir 
+                             , myproc()->memPageArray[i].virtual_Address , 0);
+          
+              if((*pte_NRU&PTE_A)!=0 && (*pte_NRU&PTE_M)==0){
+                  found=1;nruIdx = i;break;
+              }   
+          }
+      }
+      //case 4 : referenced and modified
+      if(found == 0){
+          for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+            pte_t * pte_NRU = walkpgdir(myproc()->pgdir 
+                             , myproc()->memPageArray[i].virtual_Address , 0);
+          
+            if((*pte_NRU&PTE_A)!=0 && (*pte_NRU&PTE_M)!=0){
+              found=1;nruIdx = i;break;
+            }   
+          }
+      }
+
+    char *headVa = myproc()->memPageArray[nruIdx].virtual_Address;
+     
+    myproc()->memPageArray[nruIdx].virtual_Address = (char*)0xffffffff;//setting invalid va
+    myproc()->memPageArray[nruIdx].used = 0;
+    myproc()->memPageArray[nruIdx].nextIdx = -1;
+    myproc()->headOfQueueIdx = myproc()->memPageArray[nruIdx].nextIdx;//moving head pointer forward
+    
+    //writing to swapFile
+    writeToSwapFile(myproc(), headVa, swapIdx*PGSIZE, PGSIZE);
+    
+    myproc()->swapPageArray[swapIdx].used = 1;
+    myproc()->swapPageArray[swapIdx].virtual_Address = headVa;
+
+    //free headVa
+    //pte_t *tmp_head = (pte_t*)walkpgdir(myproc()->pgdir, headVa, 0);
+    //kfree((char*)PTE_ADDR(P2V(tmp_head)));
+    kfree((char*)PTE_ADDR(P2V(*walkpgdir(myproc()->pgdir, headVa, 0)))); 
+
+    //updating flags
+    pte_t *pteHead = (pte_t*)walkpgdir(myproc()->pgdir, headVa, 0);
+    *pteHead = (*pteHead|PTE_PG)&(~PTE_P);
+    lcr3(V2P(myproc()->pgdir));
+
+    cprintf("Page from memory moved to swapFile using NRU\n");
+
+}
+
+void move_memPage_to_swapFile_FIFO(int swapIdx){
+    int headIdx = myproc()->headOfQueueIdx;
+    if(headIdx == -1){
+      panic("Queue error inside pagefault");
+    }
+
+    //getting va of the page that will be swapped out
+    char *headVa = myproc()->memPageArray[headIdx].virtual_Address;
+
+    myproc()->memPageArray[headIdx].virtual_Address = (char*)0xffffffff;//setting invalid va
+    myproc()->memPageArray[headIdx].used = 0;
+    myproc()->memPageArray[headIdx].nextIdx = -1;
+    myproc()->headOfQueueIdx = myproc()->memPageArray[headIdx].nextIdx;//moving head pointer forward
+    
+    //writing to swapFile
+    writeToSwapFile(myproc(), headVa, swapIdx*PGSIZE, PGSIZE);
+    
+    myproc()->swapPageArray[swapIdx].used = 1;
+    myproc()->swapPageArray[swapIdx].virtual_Address = headVa;
+
+    //free headVa
+    //pte_t *tmp_head = (pte_t*)walkpgdir(myproc()->pgdir, headVa, 0);
+    //kfree((char*)PTE_ADDR(P2V(tmp_head)));
+    kfree((char*)PTE_ADDR(P2V(*walkpgdir(myproc()->pgdir, headVa, 0)))); 
+
+    //updating flags
+    pte_t *pteHead = (pte_t*)walkpgdir(myproc()->pgdir, headVa, 0);
+    *pteHead = (*pteHead|PTE_PG)&(~PTE_P);
+    lcr3(V2P(myproc()->pgdir));
+
+    cprintf("Page from memory moved to swapFile Using FIFO\n");
+
+}
 
+void move_swap_page_to_memory(char* swapVa , int tmp_swapIdx){
+    char *mem = kalloc();   //new memory acquired
+    if(mem == 0){
+      panic("page fault and memory out");
+    }
+
+    int idx = -1;
+    for(int i=0; i<MAX_PSYC_PAGES; i++){
+      if(myproc()->memPageArray[i].used == 0){
+        idx = i;
+        break;
+      }
+    }
+    if(idx == -1){
+      panic("pgfault and no free slot in memory\n");
+    }
+    //idx = location where swapPage will be moved to
+
+     //swapPage to be moved to memory
+    pte_t *pteSwap;
+    pteSwap = (pte_t*)walkpgdir(myproc()->pgdir, swapVa, 0);
+    *pteSwap = ((((V2P(mem))>>12)<<12) |PTE_P|PTE_W|PTE_U ) ;//since it's going to memory , so enable these flags
+    lcr3(V2P(myproc()->pgdir));
+
+    int tail = myproc()->headOfQueueIdx;   
+    //empty queue
+    if(tail == -1){  
+        myproc()->headOfQueueIdx = idx;
+    }
+    else{
+      while(myproc()->memPageArray[tail].nextIdx != -1){
+          tail = myproc()->memPageArray[tail].nextIdx;
+      }
+      //setting tail point to the newly added page
+      myproc()->memPageArray[tail].nextIdx = idx;
+    }
+
+    //updating memPage to contain swapPage
+    myproc()->memPageArray[idx].nextIdx = -1;
+    myproc()->memPageArray[idx].used = 1;
+    myproc()->memPageArray[idx].virtual_Address = swapVa;
+
+    char buffer[PGSIZE/4];
+    memset(buffer , 0 ,PGSIZE/4);
+    int j;
+    //cprintf("luper age\n");
+    for(int i=0 ; i<4; i++){
+      j = readFromSwapFile(myproc(), buffer, tmp_swapIdx*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+      if(j==-1){
+        panic("While moving swapPage to memory : Couldn't readd from swapFile");
+      }
+      //cprintf("memmove er age\n");
+      char* dst = memmove(swapVa+i*PGSIZE/4, buffer, PGSIZE/4);
+      if(dst != (char*)swapVa+i*PGSIZE/4){
+        panic("memove not working properly");
+      }
+      memset(buffer , 0 ,PGSIZE/4);
+      //cprintf("memmove er pore\n");
+    }
+    //cprintf("luper pore\n");
+
+   
+
+    cprintf(GREEN "swap page finally moved to memory\n" RESET);
+}
+//------------------------------------------------------------------
 //PAGEBREAK: 41
 void
 trap(struct trapframe *tf)
@@ -48,6 +294,11 @@ trap(struct trapframe *tf)
 
   switch(tf->trapno){
   case T_IRQ0 + IRQ_TIMER:
+    //------------------------added by afnan-------------------
+    if(NRU){
+      reset_R();
+    }
+    //---------------------------------------------------------
     if(cpuid() == 0){
       acquire(&tickslock);
       ticks++;
@@ -55,6 +306,7 @@ trap(struct trapframe *tf)
       release(&tickslock);
     }
     lapiceoi();
+     
     break;
   case T_IRQ0 + IRQ_IDE:
     ideintr();
@@ -77,7 +329,85 @@ trap(struct trapframe *tf)
             cpuid(), tf->cs, tf->eip);
     lapiceoi();
     break;
+  //---------------added by afnan----------------------//
+  //pagefault case
+  case T_PGFLT:
+      //CR2 Contains a value called Page Fault Linear Address (PFLA).
+      //When a page fault occurs, the address the program attempted to
+      // access is stored in the CR2 register.
+      if(myproc()->pid==1){
+        break;
+      }
+
+      char* addr = (char*)rcr2();
+      print_page_fault_info(addr);
+      char* va = (char*) PGROUNDDOWN((int)addr);
+
+      //getting pgtab entry
+      pte_t *pte1 = (pte_t*)walkpgdir(myproc()->pgdir, va, 0);
+
+      //if its in swap file
+      if((*pte1 & PTE_P)==0 && (*pte1 & PTE_PG)!=0){
+        /*
+        3 steps to perform swap out andd swap in
+        //----------(1) move the swap page to a dummy swap index
+        //              located at another position in swap file
+        //              so that it doesn't get overwritten.
+        //
+        //----------(2) select which page to move from memory.
+        //              Then move that page to the swapFile in the 
+        //              actual location of swap page.
+        //
+        //----------(3) Now move the swap page , located at a dummy 
+        //              position , to the selected position of memory  
+        */
+          
+          //===========step 1===================
+          int swapIdx = -1;
+            
+          for(int i=0; i<MAX_PSYC_PAGES ; i++){
+              if(myproc()->swapPageArray[i].virtual_Address == va && myproc()->swapPageArray[i].used==1){
+                  swapIdx = i;break;
+              }
+          }
+          if(swapIdx == -1){
+            panic("Pagefault occured but page not found in swapFile\n");
+          }
+
+          char* swapVa = myproc()->swapPageArray[swapIdx].virtual_Address;
+
+          int tmp_swapIdx = MAX_PSYC_PAGES;
+          for(int i=0 ; i<MAX_PSYC_PAGES ; i++){
+              if(myproc()->swapPageArray[i].virtual_Address == (char*)0xffffffff && myproc()->swapPageArray[i].used==0){
+                  tmp_swapIdx = i;break;
+              }
+          }
+
+          char buffer[PGSIZE/4];
+          memset(buffer , 0 , PGSIZE/4);
+
+          for(int i=0 ; i<4 ; i++){
+              readFromSwapFile(myproc(), buffer, (swapIdx)*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+              writeToSwapFile(myproc(), buffer, tmp_swapIdx*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+              memset(buffer , 0 , PGSIZE/4);
+          }
+
+          cprintf("Swap page moved to a dummy page slot\n");
+          
+          //===================step 2============================
+          if(NRU){
+            move_memPage_to_swapFile_NRU(swapIdx);
+          }
+          else{
+            move_memPage_to_swapFile_FIFO(swapIdx);
+          }
+          
+          //====================step3==============================
+          move_swap_page_to_memory(swapVa , tmp_swapIdx);
+      }
+      return;
 
+  //----------------------------------------------------
   //PAGEBREAK: 13
   default:
     if(myproc() == 0 || (tf->cs&3) == 0){
diff --git a/trapasm.S b/trapasm.S
old mode 100644
new mode 100755
diff --git a/traps.h b/traps.h
old mode 100644
new mode 100755
diff --git a/types.h b/types.h
old mode 100644
new mode 100755
diff --git a/uart.c b/uart.c
old mode 100644
new mode 100755
diff --git a/ulib.c b/ulib.c
old mode 100644
new mode 100755
diff --git a/umalloc.c b/umalloc.c
old mode 100644
new mode 100755
diff --git a/user.h b/user.h
old mode 100644
new mode 100755
diff --git a/usertests.c b/usertests.c
old mode 100644
new mode 100755
index a1e97e7..69fb8a4
--- a/usertests.c
+++ b/usertests.c
@@ -1415,7 +1415,8 @@ void
 sbrktest(void)
 {
   int fds[2], pid, pids[10], ppid;
-  char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  //char *a, *b, *c, *lastaddr, *oldbrk, *p, scratch;
+  char *a, *b, *c , *oldbrk, *p, scratch;
   uint amt;
 
   printf(stdout, "sbrk test\n");
@@ -1457,8 +1458,8 @@ sbrktest(void)
     printf(stdout, "sbrk test failed to grow big address space; enough phys mem?\n");
     exit();
   }
-  lastaddr = (char*) (BIG-1);
-  *lastaddr = 99;
+  //lastaddr = (char*) (BIG-1);
+  //*lastaddr = 99;
 
   // can one de-allocate?
   a = sbrk(0);
@@ -1480,11 +1481,13 @@ sbrktest(void)
     printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
     exit();
   }
+  /*
   if(*lastaddr == 99){
     // should be zero
     printf(stdout, "sbrk de-allocation didn't really deallocate\n");
     exit();
   }
+  */
 
   a = sbrk(0);
   c = sbrk(-(sbrk(0) - oldbrk));
diff --git a/usys.S b/usys.S
old mode 100644
new mode 100755
diff --git a/vm.c b/vm.c
old mode 100644
new mode 100755
index 7134cff..5034916
--- a/vm.c
+++ b/vm.c
@@ -7,9 +7,20 @@
 #include "proc.h"
 #include "elf.h"
 
+
+
 extern char data[];  // defined by kernel.ld
 pde_t *kpgdir;  // for use in scheduler()
 
+//-----------------------added by afnan---------------------------
+//called from trap.c in case of a page fault
+//swap the last entry of memory page linkedList with an entry from swapFile pages
+void swapPage_Fifo(uint addr){
+
+}
+//----------------------------------------------------------------
+
+
 // Set up CPU's kernel segment descriptors.
 // Run once on entry on each CPU.
 void
@@ -54,6 +65,7 @@ walkpgdir(pde_t *pgdir, const void *va, int alloc)
   return &pgtab[PTX(va)];
 }
 
+
 // Create PTEs for virtual addresses starting at va that refer to
 // physical addresses starting at pa. va and size might not
 // be page-aligned.
@@ -216,6 +228,118 @@ loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
   return 0;
 }
 
+
+//-----------------------added by afnan---------------------------
+
+// takes the last page from the linked list of memory pages , ecivt it and write it to swapFile
+// finaly returns the page evicted from memory
+void
+writePagesInSwapFile(struct proc *p , uint a){
+      int headIdx = p->headOfQueueIdx;
+      if(headIdx == -1){
+        panic("QUEUE EMPTY");
+      }
+
+      char *headVa = p->memPageArray[headIdx].virtual_Address; //virtual addr of the page that need to be paged out
+
+      p->headOfQueueIdx = p->memPageArray[headIdx].nextIdx; //moving head forward
+
+      int tail = p->headOfQueueIdx;
+
+      if(tail == -1){    //queue empty,don't move head
+          p->headOfQueueIdx = headIdx;
+      }
+      else{
+          while(p->memPageArray[tail].nextIdx != -1){
+              tail = p->memPageArray[tail].nextIdx;
+          }
+      p->memPageArray[tail].nextIdx = headIdx; //connect tail to head
+
+      }
+      p->memPageArray[headIdx].virtual_Address = (char*)a;
+      p->memPageArray[headIdx].used = 1;
+      p->memPageArray[headIdx].nextIdx = -1;
+
+      //look for where to write in swapFile
+      int swapIdx = -1;
+
+      for(int i=0; i<MAX_PSYC_PAGES; i++){
+        if(p->swapPageArray[i].used == 0){
+          swapIdx = i;
+          break;
+        }
+      }
+
+      if(swapIdx==-1){
+        panic("Swap file out of memory\n");
+      }
+
+      char buf[PGSIZE/4];
+
+      for(int i=0 ; i<4; i++){
+          memmove(buf, headVa + i*PGSIZE/4, PGSIZE/4);
+          writeToSwapFile(p, buf, swapIdx*PGSIZE + i*PGSIZE/4, PGSIZE/4);
+      }
+
+      p->swapPageArray[swapIdx].used = 1;
+      p->swapPageArray[swapIdx].virtual_Address = headVa;
+
+      //p->takenPhysPage = p->takenPhysPage-1;
+      p->pagesInSwapFile = p->pagesInSwapFile+1;
+
+      //freeing the correspondiong pgdir
+      kfree((char*)PTE_ADDR(P2V(*walkpgdir(p->pgdir, headVa, 0))));
+      
+      //updating flags
+      pte_t *pteTemp = walkpgdir(p->pgdir, headVa, 0);
+      *pteTemp = (*pteTemp|PTE_PG)&(~PTE_P);
+
+      cprintf("Swapped %d to swap, allocated %d\n", headVa, a);
+
+}
+
+
+void insertPagesInMemory(struct proc *p , char* v_addr){
+    int idx = -1;
+
+    //find the next available slot
+    for(int i=0; i<MAX_PSYC_PAGES; i++){
+        if(p->memPageArray[i].used == 0){
+          idx = i;
+          break;
+        }
+    }
+
+    if(idx == -1){
+      panic("PANIC :no slot in memory\n");
+    }
+
+    int tail = p->headOfQueueIdx;
+
+    if(tail == -1){    //queue empty
+        p->headOfQueueIdx = idx;
+    }
+    else{
+        while(p->memPageArray[tail].nextIdx != -1){
+            tail = p->memPageArray[tail].nextIdx;
+        }
+      p->memPageArray[tail].nextIdx = idx;//tail pointer points to the next available location
+      p->headOfQueueIdx = idx;
+
+    }
+
+    p->memPageArray[idx].nextIdx = -1;
+    p->memPageArray[idx].used = 1;
+    p->memPageArray[idx].virtual_Address = (char*)v_addr;
+
+    p->pagesInMemory = p->pagesInMemory+1;
+
+    cprintf("\nNew Page %d allocated at idx = %d, pages in Memory = %d for pid=%d\n", v_addr, idx, p->pagesInMemory, p->pid);
+
+}
+
+//----------------------------------------------------------------
+
 // Allocate page tables and physical memory to grow process from oldsz to
 // newsz, which need not be page aligned.  Returns new size or 0 on error.
 int
@@ -230,13 +354,42 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
     return oldsz;
 
   a = PGROUNDUP(oldsz);
+  //-----------------added by afnan---------------
+  if(a == 0){
+      initNewFeatures(myproc());
+  }
+  //-----------------------------------------------
+  int free_slot_in_mem;
+  struct proc* p = myproc();
+ 
   for(; a < newsz; a += PGSIZE){
+
+    //------------------------------added by afnan----------------------------
+    cprintf("Current Size = %d\tTarget Size = %d\n" ,a , newsz);
+    free_slot_in_mem = 1;
+    if( p->pagesInMemory >= MAX_PSYC_PAGES){
+        cprintf("Inside allocuvm(): Memory FUll.Page needs to be swapped out. pid:%d, name:%s\n", p->pid, p->name);
+        
+        if(p->pagesInSwapFile<MAX_PSYC_PAGES)writePagesInSwapFile(p , a);
+        else{
+            panic("\nSwapFile FULL!! Can't write anymore!\n");
+        }
+        cprintf("Pages in SwapFile = %d\n\n" , p->pagesInSwapFile);
+        
+        free_slot_in_mem = 0;
+    }
+
     mem = kalloc();
     if(mem == 0){
-      cprintf("allocuvm out of memory\n");
-      deallocuvm(pgdir, newsz, oldsz);
-      return 0;
+        cprintf("allocuvm out of memory\n");
+        deallocuvm(pgdir, newsz, oldsz);
+        return 0;
+    }
+    
+    if(free_slot_in_mem){
+        insertPagesInMemory(p , (char*)a);
     }
+
     memset(mem, 0, PGSIZE);
     if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
       cprintf("allocuvm out of memory (2)\n");
@@ -244,6 +397,8 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
       kfree(mem);
       return 0;
     }
+
+    //-------------------------------------------------------------------
   }
   return newsz;
 }
@@ -252,9 +407,11 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 // newsz.  oldsz and newsz need not be page-aligned, nor does newsz
 // need to be less than oldsz.  oldsz can be larger than the actual
 // process size.  Returns the new process size.
+/*
 int
 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
 {
+  cprintf("newsz from deallocuvm:%d oldsz from dealloc %d\n" , newsz,oldsz);
   pte_t *pte;
   uint a, pa;
 
@@ -265,19 +422,154 @@ deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   for(; a  < oldsz; a += PGSIZE){
     pte = walkpgdir(pgdir, (char*)a, 0);
     if(!pte)
-      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
-    else if((*pte & PTE_P) != 0){
+      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;//// construct virtual address from indexes and offset
+    else if((*pte & PTE_P) != 0){//should remove from main memory
       pa = PTE_ADDR(*pte);
       if(pa == 0)
         panic("kfree");
+      
+      //----------------------------------------------------------------
       char *v = P2V(pa);
       kfree(v);
       *pte = 0;
     }
+    //------------------------added by afnan----------------------------
+    else{
+        
+    //-------------------------------------------------------------------
+  }
+  return newsz;
+}
+*/
+
+int
+deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
+{
+  //cprintf("Deallocuvm oldsz = %d  , newsz= %d\n" , oldsz , newsz);
+  pte_t *pte;
+  uint a, pa;
+
+  struct proc *p = myproc();
+
+  if(newsz >= oldsz)
+    return oldsz;
+
+  a = PGROUNDUP(newsz);
+  for(; a  < oldsz; a += PGSIZE){
+    pte = walkpgdir(pgdir, (char*)a, 0);
+
+      if(!pte){
+        a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
+      }
+      else if((*pte & PTE_P) != 0){ 
+        //--------------------------------added by afnan-------------------------
+        //should remove from main memory
+        if(!not_init_or_sh(p)){
+          goto Memory_Bypass;
+        }
+
+        //memory corresponding to va must be deallocated
+        char *va = (char*) a;
+
+        //modifying queue
+        int idx = -1;
+        int parentIdx = -1;
+
+        //finding the idx whose memPageArray needs to be deallocated
+        for(int i=0; i<MAX_PSYC_PAGES; i++){
+          if(p->memPageArray[i].virtual_Address == va && p->memPageArray[i].used == 1){
+            idx = i;
+            break;
+          }
+        }
+
+        if(idx == -1){
+            //no such idx found,bypass the memory deallocation
+            goto Memory_Bypass;
+        }
+
+        //if the head needs to be deallocated , then forward the headd pointer
+        if(idx == p->headOfQueueIdx){ 
+          p->headOfQueueIdx = p->memPageArray[idx].nextIdx;
+        }
+        else{
+          //otherwise find the location of idx to deallocate
+          parentIdx = p->headOfQueueIdx;
+          while(p->memPageArray[parentIdx].nextIdx != idx && p->memPageArray[parentIdx].nextIdx != -1){
+            parentIdx = p->memPageArray[parentIdx].nextIdx;
+          }
+
+          //idx still not found
+          if(p->memPageArray[parentIdx].nextIdx != idx){
+            goto Memory_Bypass;
+          }
+
+          //Skipping idx , parent of idx points to the next of idx
+          p->memPageArray[parentIdx].nextIdx = p->memPageArray[idx].nextIdx; 
+        }
+
+        p->memPageArray[idx].virtual_Address = (char*)0xffffffff;
+        p->memPageArray[idx].used = 0;
+        p->memPageArray[idx].nextIdx = -1;
+
+        p->pagesInMemory--;
+
+        cprintf("Deallocuvm(): Deallocated %d from Memory for pid=%d, name=%s\n", a, p->pid, p->name);
+
+    Memory_Bypass:
+
+        pa = PTE_ADDR(*pte);
+
+        if(pa == 0)
+          panic("kfree");
+        char *v = P2V(pa);
+        kfree(v);
+
+        *pte = 0;
+
+     }
+     //this virtual addr resides in swap file
+      else if( (*pte&PTE_P)==0 && (*pte&(~PTE_PG))!=0 ){  
+
+        if(strncmp(p->name, "init", 4)==0 ){ 
+          goto Swap_Bypass;
+        }
+
+      
+      char *va = (char*) a;
+
+      int swapIdx = -1;
+      for(int i=0; i<MAX_PSYC_PAGES; i++){
+        if(p->swapPageArray[i].virtual_Address == va && p->swapPageArray[i].used == 1){
+          swapIdx = i;
+          break;
+        }
+      }
+      //not found
+      if(swapIdx==-1){
+        goto Swap_Bypass;
+      }
+
+      p->swapPageArray[swapIdx].virtual_Address = (char*)0xffffffff;
+      p->swapPageArray[swapIdx].used = 0;
+
+      p->pagesInSwapFile--;
+
+      cprintf("Deallocuvm(): Deallocated %d from SWAP. pid=%d, name=%s\n", va, p->pid, p->name);
+
+
+    Swap_Bypass:
+
+      *pte = 0;
+
+    }
   }
+
   return newsz;
+
 }
 
+
 // Free a page table and all the physical memory pages
 // in the user part.
 void
@@ -310,11 +602,26 @@ clearpteu(pde_t *pgdir, char *uva)
   *pte &= ~PTE_U;
 }
 
+
+void update_pte_flags(struct proc* p, int vAddr, pde_t * pgdir){
+
+  pte_t *pte = walkpgdir(pgdir, (int*)vAddr, 0);
+  if (!pte)
+    panic("update_pte_flags: pte does NOT exist in pgdir");
+
+  *pte |= PTE_PG;           // setting PTE_PG
+  *pte &= ~PTE_P;           // resetting PTE_P
+  *pte &= PTE_FLAGS(*pte);  // marks the first 20 bits zero , keeps only flags
+
+  lcr3(V2P(p->pgdir));      // Refresh CR3 register (TLB (cache))
+}
+
 // Given a parent process's page table, create a copy
 // of it for a child.
 pde_t*
 copyuvm(pde_t *pgdir, uint sz)
 {
+  struct proc* p = myproc();
   pde_t *d;
   pte_t *pte;
   uint pa, i, flags;
@@ -325,6 +632,12 @@ copyuvm(pde_t *pgdir, uint sz)
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
       panic("copyuvm: pte should exist");
+    //-------------------------added by afnan--------------------
+    if((*pte & PTE_PG)){
+        update_pte_flags(p , i , d);
+        continue;
+    }
+    //-----------------------------------------------------------
     if(!(*pte & PTE_P))
       panic("copyuvm: page not present");
     pa = PTE_ADDR(*pte);
diff --git a/wc.c b/wc.c
old mode 100644
new mode 100755
diff --git a/x86.h b/x86.h
old mode 100644
new mode 100755
index 07312a5..ae2d665
--- a/x86.h
+++ b/x86.h
@@ -1,5 +1,13 @@
 // Routines to let C code use special x86 instructions.
 
+//--------------added by afnan--------
+//for minimizing cpu usage
+static inline void
+halt()
+{
+  asm volatile("hlt" : : );
+}
+//-------------------------------
 static inline uchar
 inb(ushort port)
 {
diff --git a/zombie.c b/zombie.c
old mode 100644
new mode 100755
